//#download "menu.ric"

#define X (100)
#define Y (64)

#define MAX_BRUSH_SIZE (5) //just a random number

//definition of menu cursor positions
#define menu1 58
#define menu2 49
#define menu3 41
#define menu4 33
#define menu5 25
#define menu6 17
#define menu7 9


//afterwards the functions should be arranged in the same order as here
void openMenu();
sub navi();
bool openSubMenu(int item);
sub brush(int x, int y);
sub setBrushSize();
sub eraser(int x, int y);
sub markCircularArea(int x0, int y0);
sub clearScreen();
sub saveImage();
sub restoreImage();

bool pixels[X][Y];     //bookkeeping of coloured pixels, init values all false
int item[] = {menu1, menu2, menu3, menu4, menu5, menu6, menu7};
int menu[] = {menu1};// menu cursor position, MUST be array, init value menu1

bool clearFlag = false;     //exit screen without restoring image
bool eraserFlag = false;    //eraser on/off
int radius;

task main()
{
 //init sensors
 SetSensorType(OUT_B, SENSOR_TYPE_ROTATION); //Port B, x-axis
 SetSensorType(OUT_C, SENSOR_TYPE_ROTATION); //Port C, y-axis
 ClearSensor(OUT_B); ClearSensor(OUT_C);

 int x, y;
 radius = 1;
 
 while(TRUE)
  {
   if(ButtonPressed(BTNCENTER,false)){
    openMenu();
   }

   x=MotorTachoCount(OUT_B); // get line start
   y=MotorTachoCount(OUT_C);
 
   x = x/10; y = y/-10;  //scale the input to screen
 
   if(x>X-1) {x=X-1;} else if (x<0) x = 0;  //make sure to stay within
   if(y>Y-1) {y=Y-1;} else if (y<0) y = 0;  //boundaries of the array
 
   if(!eraserFlag){
    brush(x,y);  //draw the point, radius under 1 makes 1 pixel line
   }else{
    eraser(x,y); //erase pixels
   }
   

 }
}


//if possible, this should be in a separate file
void openMenu()
{
  ClearScreen();                        //clear screen to see menu
  GraphicOutEx(0, 0, "menu.ric", menu); //open menu with def cursor position
  navi();                               //handle menu navigation
  ClearScreen();
  if (!clearFlag) {
     restoreImage();    //restore image data
     clearFlag = false;
  }
}


sub navi(){
 int pos = 0;
 bool cont = true; //if the exit button can be remapped to not automatically
                   //program, then this flag should be removed
                       
 while(cont){      //ugly set of if-else >.<
   if(ButtonPressed(BTNLEFT,true)){        //go back in menu
     pos--;
   }
    else if(ButtonPressed(BTNRIGHT,true)){ //go forward in menu
     pos++;
   }

   if(pos<0) { //make sure to stay within boundaries
    pos = 0;
   }
    else if (pos>ArrayLen(item)-1){
    pos=ArrayLen(item)-1;
   }
   
   menu[0]=item[pos]; //update position
   ClearScreen();
   GraphicOutEx(0, 0, "menu.ric", menu, DRAW_OPT_CLEAR_PIXELS); //update menu
   Wait(200);  //wait, otherwise it's difficult to hit the menu items :)
   
   if(ButtonPressed(BTNCENTER,false)){
    cont = openSubMenu(pos);
   }
   
 }
}


bool openSubMenu(int item){ //returns false only when main menu must be closed
Wait(200); //waiting time prevents interference
 switch(item){   //submenu calls to be inserted here, if a submenu is needed
  case 0: //open
      break;
  case 1: //brush
      eraserFlag = false;
      setBrushSize();
      break;
  case 2: //eraser
      eraserFlag = true;
      break;
  case 3: //clear
      clearScreen();
      break;
  case 4: //games
      break;
  case 5: //save
      saveImage();
      break;
  case 6: //exit menu
      return false;
  default:
      return true;
 }
 Wait(200);
 return true;
}


sub brush(int x, int y){
 //TextOut(0, LCD_LINE1, "X=");  //debug info
 //TextOut(0, LCD_LINE2, "Y=");
 //NumOut(10, LCD_LINE1, x);
 //NumOut(10, LCD_LINE2, y);

 if (radius == 1){
  pixels[x][y]=true;
  PointOut(x, y);
 }
 else { //needs different bookkeeping
  markCircularArea(x,y); //fills a circular area in the array
  CircleOut(x, y, radius);
 }
}


sub setBrushSize(){
ClearScreen();
TextOut(0, LCD_LINE4, "Brush Size: ");
int size = 1;
 while(!ButtonPressed(BTNCENTER,true)){
   if(ButtonPressed(BTNLEFT,true)){        //smaller size
     size--;
   }
    else if(ButtonPressed(BTNRIGHT,true)){ //bigger size
     size++;
   }

   if(size<1) { //make sure to stay within range
    size = 1;
   }
    else if (size>MAX_BRUSH_SIZE){
    size=MAX_BRUSH_SIZE;
   }
  NumOut(70, LCD_LINE4, size);
  Wait(200);
 }
radius = size;
}


sub eraser(int x, int y){
 pixels[x][y]=false;
 int i;
 for (i=0; i<X;i++){
  if(pixels[i][y]==true)
   PointOut(i, y);
 }
}

sub markCircularArea(int x0, int y0){
//Bresenham's circle algorithm
//lacks boundaries check yet!!!
 int f = 1 - radius;
 int ddF_x = 1;           //partial derivatives, just ignore
 int ddF_y = -2 * radius;
 int x = 0;
 int y = radius;

 pixels[x0][y0 + radius]=true;
 pixels[x0][y0 - radius]=true;
 pixels[x0 + radius][y0]=true;
 pixels[x0 - radius][y0]=true;

 while(x < y)
 {
   // ddF_x == 2 * x + 1;
   // ddF_y == -2 * y;
   // f == x*x + y*y - radius*radius + 2*x - y + 1;
   if(f >= 0)
   {
     y--;
     ddF_y += 2;
     f += ddF_y;
   }
   x++;
   ddF_x += 2;
   f += ddF_x;
   pixels[x0 + x][y0 + y]=true;
   pixels[x0 - x][y0 + y]=true;
   pixels[x0 + x][y0 - y]=true;
   pixels[x0 - x][y0 - y]=true;
   pixels[x0 + y][y0 + x]=true;
   pixels[x0 - y][y0 + x]=true;
   pixels[x0 + y][y0 - x]=true;
   pixels[x0 - y][y0 - x]=true;
 }
}


sub clearScreen(){
 clearFlag = true;
 int j,k;
 for (j=0;j<X;j++){
  for (k=0;k<Y;k++){
   pixels[j][k]=false;
  }
 }
}


sub saveImage(){}    //write image data to file


sub restoreImage()   //load image data from array
{
 int i,j;
 for(i = 0; i<X;i++){
  for(j = 0; j<Y;j++){
    if(pixels[i][j]){
     PointOut(i,j);
    }
  }
 }
}

